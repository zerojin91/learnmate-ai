"""
Mentor Chat MCP Server - 전문가 멘토링 상담 시스템
- LangGraph 기반 2단계 워크플로우 (페르소나 추천 → 전문가 멘토링)
- 10개 전문 분야 페르소나 지원
- 세션 기반 상태 관리
"""

from mcp.server.fastmcp import FastMCP
from pydantic import BaseModel, Field
from typing import TypedDict, List, Dict, Optional
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, START, END
from langgraph.types import Command
import json
import logging
from datetime import datetime
import uuid
import os
import sys
import httpx
import re

# 상위 디렉토리의 config 모듈 import
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config import Config
from utils import random_uuid

# 로깅 설정
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 세션 저장 폴더 경로
SESSIONS_DIR = "sessions"
MENTOR_SESSIONS_DIR = os.path.join(SESSIONS_DIR, "mentor")

def ensure_mentor_sessions_dir():
    """멘토 세션 폴더가 없으면 생성"""
    if not os.path.exists(MENTOR_SESSIONS_DIR):
        os.makedirs(MENTOR_SESSIONS_DIR)

def get_mentor_session_file_path(session_id):
    """멘토 세션 ID에 따른 파일 경로 반환"""
    ensure_mentor_sessions_dir()
    return os.path.join(MENTOR_SESSIONS_DIR, f"mentor_{session_id}.json")

def load_mentor_session(session_id):
    """특정 멘토 세션 데이터를 파일에서 로드"""
    try:
        session_file = get_mentor_session_file_path(session_id)
        if os.path.exists(session_file):
            with open(session_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None
    except Exception as e:
        logger.error(f"멘토 세션 {session_id} 로드 오류: {e}")
        return None

def save_mentor_session(session_id, session_data):
    """특정 멘토 세션 데이터를 파일에 저장"""
    try:
        session_file = get_mentor_session_file_path(session_id)
        with open(session_file, 'w', encoding='utf-8') as f:
            json.dump(session_data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.error(f"멘토 세션 {session_id} 저장 오류: {e}")

# 페르소나별 검색 키워드 매핑
PERSONA_KEYWORDS = {
    "architecture": "건축 설계 구조 BIM CAD 건물 인테리어 도시건축",
    "civil_urban": "토목 도시계획 인프라 교통 지반공학 구조역학 건설",
    "transport": "교통 물류 운송 모빌리티 시스템 스마트모빌리티 교통정책",
    "mechanical": "기계 설계 제조 자동화 열역학 유체역학 생산공학",
    "electrical": "전기 전자 회로 제어 전력 시스템 신호처리 임베디드",
    "precision_energy": "에너지 신재생 정밀 측정 효율 에너지시스템",
    "materials": "신소재 나노 고분자 세라믹 재료 금속재료 재료과학",
    "computer": "프로그래밍 소프트웨어 AI 네트워크 데이터베이스 컴퓨터공학",
    "industrial": "산업공학 품질 생산 최적화 공급망 린제조 6시그마",
    "chemical": "화학공학 공정 반응 분리 플랜트 화학 안전공학"
}

# 전문 분야 페르소나 정의
PERSONAS = {
    "architecture": {
        "name": "건축",
        "expertise": "건축 설계, 건축 구조, 건축 환경, BIM, 인테리어 디자인, 도시건축",
        "system_prompt": """당신은 20년 경력의 건축 전문가입니다. 
건축 설계, 구조 설계, 건축 환경, BIM, 인테리어 디자인 등 건축 분야 전반에 대한 깊은 지식을 가지고 있습니다.
실무 경험을 바탕으로 학생들과 신입 건축가들에게 실용적이고 구체적인 조언을 제공합니다.
복잡한 개념을 쉽게 설명하고, 실제 프로젝트 사례를 들어 설명하는 것을 좋아합니다."""
    },
    "civil_urban": {
        "name": "토목 도시",
        "expertise": "토목공학, 도시계획, 도시설계, 지반공학, 구조역학, 교통공학",
        "system_prompt": """당신은 토목공학과 도시계획 분야의 전문가입니다.
지반공학, 구조역학, 교통공학, 도시계획 및 설계 등에 대한 전문 지식을 보유하고 있습니다.
도시 인프라 구축과 관련된 실무 경험이 풍부하며, 지속가능한 도시 발전에 대한 통찰력을 가지고 있습니다.
이론과 실무를 연결하여 설명하며, 현실적인 문제 해결 방안을 제시합니다."""
    },
    "transport": {
        "name": "교통 운송",
        "expertise": "교통시스템, 물류관리, 교통정책, 스마트 모빌리티, 운송경제학",
        "system_prompt": """당신은 교통 및 운송 시스템 전문가입니다.
교통 시스템 설계, 물류 관리, 교통 정책, 스마트 모빌리티 등에 대한 전문성을 가지고 있습니다.
미래 교통 기술과 정책 동향에 대한 깊은 이해를 바탕으로, 효율적이고 지속가능한 교통 솔루션을 제안합니다.
데이터 기반의 분석과 정책적 관점에서 조언을 제공합니다."""
    },
    "mechanical": {
        "name": "기계 금속",
        "expertise": "기계설계, 재료공학, 생산공학, 자동화, 열역학, 유체역학",
        "system_prompt": """당신은 기계공학과 금속재료 분야의 전문가입니다.
기계 설계, 재료 공학, 생산 공학, 자동화 시스템 등에 대한 폭넓은 지식을 보유하고 있습니다.
제조업 현장에서의 실무 경험을 바탕으로, 이론과 실제 적용 사례를 연결하여 설명합니다.
혁신적인 기계 기술과 미래 제조업 트렌드에 대한 통찰력을 제공합니다."""
    },
    "electrical": {
        "name": "전기 전자",
        "expertise": "전기공학, 전자회로, 제어시스템, 전력시스템, 신호처리, 임베디드",
        "system_prompt": """당신은 전기전자공학 분야의 전문가입니다.
전기 회로, 전자 회로, 제어 시스템, 전력 시스템, 신호 처리 등에 대한 깊은 지식을 가지고 있습니다.
최신 전자 기술 동향과 실무 적용 경험을 바탕으로, 복잡한 개념을 체계적으로 설명합니다.
이론적 기반과 실용적 접근 방법을 균형있게 제시합니다."""
    },
    "precision_energy": {
        "name": "정밀 에너지",
        "expertise": "정밀기기, 측정공학, 에너지시스템, 신재생에너지, 에너지효율",
        "system_prompt": """당신은 정밀 기기 및 에너지 시스템 전문가입니다.
정밀 측정, 에너지 시스템 설계, 신재생 에너지, 에너지 효율 등에 대한 전문 지식을 보유하고 있습니다.
지속가능한 에너지 솔루션과 정밀 기술의 융합에 대한 깊은 이해를 가지고 있습니다.
기술적 정확성과 환경적 고려사항을 모두 반영한 조언을 제공합니다."""
    },
    "materials": {
        "name": "소재 재료",
        "expertise": "신소재, 나노기술, 재료과학, 고분자, 세라믹, 금속재료",
        "system_prompt": """당신은 소재 및 재료과학 분야의 전문가입니다.
신소재 개발, 나노 기술, 고분자, 세라믹, 금속 재료 등에 대한 전문성을 가지고 있습니다.
미래 소재 기술과 산업 응용에 대한 깊은 통찰력을 보유하고 있습니다.
기초 과학과 산업 응용을 연결하여, 실용적이면서도 혁신적인 접근 방법을 제시합니다."""
    },
    "computer": {
        "name": "컴퓨터 통신",
        "expertise": "소프트웨어공학, 네트워크, 데이터베이스, AI/ML, 사이버보안, 클라우드",
        "system_prompt": """당신은 컴퓨터공학과 통신 분야의 전문가입니다.
소프트웨어 개발, 네트워크 시스템, 데이터베이스, 인공지능, 사이버보안 등에 대한 깊은 지식을 가지고 있습니다.
최신 기술 트렌드와 산업 동향을 잘 파악하고 있으며, 실무 중심의 조언을 제공합니다.
이론적 배경과 실제 구현 경험을 바탕으로, 체계적이고 실용적인 가이드를 제시합니다."""
    },
    "industrial": {
        "name": "산업",
        "expertise": "산업공학, 품질관리, 생산관리, 공급망관리, 린제조, 6시그마",
        "system_prompt": """당신은 산업공학 및 생산관리 전문가입니다.
생산 시스템 최적화, 품질 관리, 공급망 관리, 린 제조, 6시그마 등에 대한 전문 지식을 보유하고 있습니다.
기업의 운영 효율성 향상과 경쟁력 강화에 대한 실무 경험이 풍부합니다.
데이터 분석과 시스템적 사고를 바탕으로, 실질적인 개선 방안을 제안합니다."""
    },
    "chemical": {
        "name": "화공",
        "expertise": "화학공학, 공정설계, 반응공학, 분리공정, 화학플랜트, 안전공학",
        "system_prompt": """당신은 화학공학 분야의 전문가입니다.
화학 공정 설계, 반응 공학, 분리 공정, 화학 플랜트 운영 등에 대한 깊은 지식을 가지고 있습니다.
산업 현장에서의 안전과 효율성을 중시하며, 환경 친화적인 공정 설계에 대한 전문성을 보유하고 있습니다.
이론과 실무를 균형있게 접근하여, 안전하고 효율적인 솔루션을 제시합니다."""
    }
}

# 상태 스키마 정의
class MentorState(TypedDict):
    messages: List[Dict[str, str]]
    phase: str  # "persona_recommendation" | "mentoring"
    recommended_personas: List[Dict[str, str]]  # 추천된 페르소나 정보
    selected_persona: str  # 선택된 페르소나 ID
    persona_context: str  # 페르소나 전문 지식 컨텍스트
    session_id: str
    completed: bool

# 스키마 모델들
class PersonaRecommendation(BaseModel):
    recommended_personas: List[Dict[str, str]] = Field(description="추천된 페르소나 목록")
    reasoning: str = Field(description="추천 이유")

class SelectionResult(BaseModel):
    selected_persona: str = Field(description="선택된 페르소나 ID")
    persona_name: str = Field(description="선택된 페르소나 이름")
    message: str = Field(description="멘토 인사말")

class MentoringResponse(BaseModel):
    response: str = Field(description="전문가 멘토링 응답")
    persona_name: str = Field(description="응답한 페르소나 이름")
    related_courses: List[Dict] = Field(default=[], description="관련 K-MOOC 강좌")
    related_documents: List[Dict] = Field(default=[], description="관련 문서 자료")

# LLM 설정
llm = ChatOpenAI(
    base_url=Config.LLM_BASE_URL,
    api_key=Config.LLM_API_KEY,
    model=Config.LLM_MODEL,
    temperature=0.7,
    max_tokens=2000,
)

# MCP 서버 생성
mcp = FastMCP("MentorChat")

# K-MOOC 요약 정보 파싱 함수 (generate_curriculum.py에서 가져옴)
def parse_kmooc_summary(summary: str) -> dict:
    """K-MOOC 요약에서 구조화된 정보 추출"""
    try:
        parsed_info = {}
        
        # 제목 추출
        title_match = re.search(r'\*\*제목:\*\*\s*([^\n*]+)', summary)
        if title_match:
            parsed_info["title"] = title_match.group(1).strip()
        
        # 설명 추출
        desc_match = re.search(r'\*\*설명:\*\*\s*([^\n*]+)', summary)
        if desc_match:
            parsed_info["description"] = desc_match.group(1).strip()
        
        # 강좌 목표 추출
        goal_match = re.search(r'\*\*강좌 목표:\*\*\s*([^\n*]+)', summary)
        if goal_match:
            parsed_info["course_goal"] = goal_match.group(1).strip()
        
        # 난이도 추출
        difficulty_match = re.search(r'\*\*난이도:\*\*\s*([^\n*]+)', summary)
        if difficulty_match:
            parsed_info["difficulty"] = difficulty_match.group(1).strip()
        
        # 수업 시간 추출
        time_match = re.search(r'\*\*수업 시간:\*\*[^()]*약\s*([^\n*()]+)', summary)
        if time_match:
            parsed_info["class_time"] = time_match.group(1).strip()
        
        return parsed_info
        
    except Exception as e:
        logger.error(f"K-MOOC 요약 파싱 실패: {e}")
        return {}

# K-MOOC 검색 함수
async def search_kmooc_for_mentoring(query: str, persona_id: str) -> List[Dict]:
    """멘토링을 위한 K-MOOC 강좌 검색"""
    try:
        # 페르소나별 검색 키워드 추가
        persona_keywords = PERSONA_KEYWORDS.get(persona_id, "")
        enhanced_query = f"{query} {persona_keywords}"
        
        search_payload = {
            "query": enhanced_query,
            "top_k": 3,  # 멘토링에는 3개 정도만
            "namespace": "kmooc_engineering",
            "rerank": True,
            "include_metadata": True
        }
        
        logger.info(f"K-MOOC 검색 시작 - query: {enhanced_query}")
        
        # pinecone_search_kmooc.py 서버 호출
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8099/search",
                json=search_payload,
                timeout=10.0
            )
            
        if response.status_code == 200:
            result = response.json()
            kmooc_courses = []
            
            for item in result.get("results", [])[:3]:  # 상위 3개만
                metadata = item.get("metadata", {})
                if metadata:
                    # Summary 파싱하여 강좌 정보 추출
                    summary = metadata.get("summary", "")
                    parsed_info = parse_kmooc_summary(summary)
                    
                    course_title = parsed_info.get("title") or "K-MOOC 강좌"
                    description = (
                        parsed_info.get("description") or 
                        parsed_info.get("course_goal") or 
                        "K-MOOC 온라인 강좌"
                    )
                    
                    course_info = {
                        "title": course_title,
                        "description": description,
                        "url": metadata.get("url", ""),
                        "institution": metadata.get("institution", "").replace(" 운영기관 바로가기새창열림", ""),
                        "course_goal": parsed_info.get("course_goal", ""),
                        "duration": parsed_info.get("duration", ""),
                        "difficulty": parsed_info.get("difficulty", ""),
                        "class_time": parsed_info.get("class_time", ""),
                        "score": item.get("score", 0.0),
                        "source": "K-MOOC"
                    }
                    kmooc_courses.append(course_info)
                    
            logger.info(f"K-MOOC 검색 완료 - {len(kmooc_courses)}개 강좌 발견")
            return kmooc_courses
            
    except Exception as e:
        logger.error(f"K-MOOC 검색 실패: {e}")
    
    return []

# 문서 검색 함수
async def search_documents_for_mentoring(query: str, persona_id: str) -> List[Dict]:
    """멘토링을 위한 문서 자료 검색"""
    try:
        # 페르소나별 검색 키워드 추가
        persona_keywords = PERSONA_KEYWORDS.get(persona_id, "")
        enhanced_query = f"{query} {persona_keywords}"
        
        search_payload = {
            "query": enhanced_query,
            "top_k": 2,  # 문서는 2개 정도
            "namespace": "main",
            "rerank": True,
            "include_metadata": True
        }
        
        logger.info(f"문서 검색 시작 - query: {enhanced_query}")
        
        # pinecone_search_document.py 서버 호출
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "http://localhost:8091/search",
                json=search_payload,
                timeout=10.0
            )
            
        if response.status_code == 200:
            result = response.json()
            documents = []
            
            for item in result.get("results", [])[:2]:  # 상위 2개만
                metadata = item.get("metadata", {})
                score = item.get("score", 0.0)
                
                if metadata and score > 0.5:  # 관련성 임계값
                    preview = metadata.get("preview", "").strip()
                    file_path = metadata.get("file_path", "").strip()
                    folder = metadata.get("folder", "").strip()
                    
                    # 파일명에서 제목 추출
                    doc_title = "PDF 문서"
                    if file_path:
                        filename = file_path.split("/")[-1] if "/" in file_path else file_path
                        if filename.endswith('.pdf'):
                            filename = filename[:-4]
                        doc_title = filename
                    
                    # 카테고리 정보
                    category = folder or "기타"
                    
                    doc_info = {
                        "title": doc_title,
                        "category": category,
                        "preview": preview[:300] + "..." if preview else "",
                        "file_path": file_path,
                        "page": metadata.get("page", ""),
                        "score": score,
                        "source": "Document DB"
                    }
                    documents.append(doc_info)
                    
            logger.info(f"문서 검색 완료 - {len(documents)}개 문서 발견")
            return documents
            
    except Exception as e:
        logger.error(f"문서 검색 실패: {e}")
    
    return []

# 검색 결과 포맷팅 함수
def format_search_results(kmooc_courses: List[Dict], documents: List[Dict]) -> str:
    """검색 결과를 멘토링 컨텍스트로 포맷팅"""
    context = ""
    
    # K-MOOC 강좌 정보
    if kmooc_courses:
        context += "📚 관련 K-MOOC 강좌:\n"
        for course in kmooc_courses:
            context += f"- {course['title']}\n"
            context += f"  운영기관: {course.get('institution', 'N/A')}\n"
            context += f"  내용: {course.get('description', '')[:200]}...\n"
            context += f"  난이도: {course.get('difficulty', 'N/A')}\n\n"
    
    # 문서 자료 정보
    if documents:
        context += "📄 참고 문서:\n"
        for doc in documents:
            context += f"- {doc['title']}\n"
            context += f"  카테고리: {doc.get('category', 'N/A')}\n"
            context += f"  내용: {doc.get('preview', '')[:150]}...\n\n"
    
    return context

@mcp.tool()
async def analyze_and_recommend_personas(message: str, session_id: str) -> PersonaRecommendation:
    """사용자 메시지를 분석하여 적절한 페르소나 추천"""
    
    logger.info(f"[RECOMMEND] 시작 - session_id: {session_id}, message: {message[:50]}...")
    
    # 세션 데이터 로드 또는 초기화
    session_data = load_mentor_session(session_id)
    if not session_data:
        session_data = {
            "session_id": session_id,
            "phase": "persona_recommendation",
            "messages": [],
            "recommended_personas": [],
            "selected_persona": "",
            "persona_context": "",
            "completed": False
        }
    
    # 메시지 추가
    session_data["messages"].append({"role": "user", "content": message})
    
    # 페르소나 추천을 위한 프롬프트 생성
    analysis_prompt = f"""
사용자의 메시지를 분석하여 가장 적합한 전문가 페르소나를 추천해주세요.

사용자 메시지: "{message}"

사용 가능한 페르소나들:
{json.dumps({k: v["name"] + " - " + v["expertise"] for k, v in PERSONAS.items()}, ensure_ascii=False, indent=2)}

요구사항:
1. 사용자의 관심사, 질문 내용, 학습 목표를 분석
2. 1-3개의 가장 적합한 페르소나를 추천
3. 각 추천에 대한 구체적인 이유 제시

**중요: 정확히 아래 JSON 형식으로만 응답하세요. 다른 텍스트는 포함하지 마세요.**

{{
    "recommended_personas": [
        {{"id": "persona_id", "name": "페르소나명", "reason": "추천 이유"}},
        ...
    ],
    "reasoning": "전체적인 분석 및 추천 근거"
}}
"""
    
    try:
        response = await llm.ainvoke(analysis_prompt)
        logger.info(f"LLM 응답: {response.content}")  # 디버깅용 로그
        
        # JSON 응답 정리
        clean_content = response.content.strip()
        # 잘못된 키 수정
        clean_content = clean_content.replace('"recommended_ personas"', '"recommended_personas"')
        clean_content = clean_content.replace('" reasoning"', '"reasoning"')
        # 배열에서 ... 제거
        clean_content = clean_content.replace(', ...', '').replace('... ', '').replace('...', '')
        # 빈 객체 제거
        clean_content = clean_content.replace(', {}', '').replace('{},', '').replace('{}', '')
        # 배열 끝 불필요한 쉼표 제거 (JSON 파싱 오류 해결)
        clean_content = clean_content.replace('}, \n     ]', '} \n     ]')
        clean_content = clean_content.replace('},\n     ]', '}\n     ]')
        clean_content = clean_content.replace('}, ]', '} ]')
        clean_content = clean_content.replace('},]', '}]')
        
        result = json.loads(clean_content)
        logger.info(f"파싱된 결과: {result}")  # 디버깅용 로그
        
        # 키 존재 여부 확인 및 안전한 추출
        recommended_personas = result.get("recommended_personas", [])
        reasoning = result.get("reasoning", "추천 이유를 찾을 수 없습니다.")
        
        # 빈 리스트인 경우 기본값 설정
        if not recommended_personas:
            # 메시지 내용으로부터 간단한 추천 로직
            message_lower = message.lower()
            if any(word in message_lower for word in ["건축", "설계", "건물"]):
                recommended_personas = [{"id": "architecture", "name": "건축", "reason": "건축 관련 키워드 감지"}]
            elif any(word in message_lower for word in ["전기", "전자", "회로"]):
                recommended_personas = [{"id": "electrical", "name": "전기 전자", "reason": "전기전자 관련 키워드 감지"}]
            elif any(word in message_lower for word in ["화공", "화학", "공정"]):
                recommended_personas = [{"id": "chemical", "name": "화공", "reason": "화학공학 관련 키워드 감지"}]
            elif any(word in message_lower for word in ["기계", "설계", "제조"]):
                recommended_personas = [{"id": "mechanical", "name": "기계 금속", "reason": "기계공학 관련 키워드 감지"}]
            elif any(word in message_lower for word in ["토목", "도시", "건설"]):
                recommended_personas = [{"id": "civil_urban", "name": "토목 도시", "reason": "토목/도시 관련 키워드 감지"}]
            elif any(word in message_lower for word in ["컴퓨터", "프로그래밍", "웹", "소프트웨어"]):
                recommended_personas = [{"id": "computer", "name": "컴퓨터 통신", "reason": "컴퓨터 관련 키워드 감지"}]
            else:
                recommended_personas = [{"id": "computer", "name": "컴퓨터 통신", "reason": "기본 추천"}]
        
        # 세션에 추천 결과 저장
        session_data["recommended_personas"] = recommended_personas
        session_data["messages"].append({
            "role": "assistant", 
            "content": f"분석 결과를 바탕으로 다음 전문가들을 추천드립니다:\n\n{reasoning}"
        })
        
        save_mentor_session(session_id, session_data)
        
        # 세션 저장 확인용 로그
        session_file_path = get_mentor_session_file_path(session_id)
        logger.info(f"세션 저장 완료 - 파일: {session_file_path}")
        logger.info(f"저장된 파일 존재 확인: {os.path.exists(session_file_path)}")
        
        # 최종 결과 로깅
        logger.info(f"[RECOMMEND] 완료 - session_id: {session_id}, 추천: {[p['id'] for p in recommended_personas]}")
        
        return PersonaRecommendation(
            recommended_personas=recommended_personas,
            reasoning=reasoning
        )
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON 파싱 오류: {e}, 응답 내용: {response.content if 'response' in locals() else 'N/A'}")
        # 기본 키워드 기반 추천으로 폴백
        message_lower = message.lower()
        if any(word in message_lower for word in ["건축", "설계", "건물"]):
            fallback_personas = [{"id": "architecture", "name": "건축", "reason": "키워드 기반 추천"}]
        elif any(word in message_lower for word in ["전기", "전자", "회로"]):
            fallback_personas = [{"id": "electrical", "name": "전기 전자", "reason": "키워드 기반 추천"}]
        elif any(word in message_lower for word in ["화공", "화학", "공정"]):
            fallback_personas = [{"id": "chemical", "name": "화공", "reason": "키워드 기반 추천"}]
        elif any(word in message_lower for word in ["기계", "설계", "제조"]):
            fallback_personas = [{"id": "mechanical", "name": "기계 금속", "reason": "키워드 기반 추천"}]
        elif any(word in message_lower for word in ["토목", "도시", "건설"]):
            fallback_personas = [{"id": "civil_urban", "name": "토목 도시", "reason": "키워드 기반 추천"}]
        elif any(word in message_lower for word in ["컴퓨터", "프로그래밍", "웹", "소프트웨어"]):
            fallback_personas = [{"id": "computer", "name": "컴퓨터 통신", "reason": "키워드 기반 추천"}]
        else:
            fallback_personas = [{"id": "computer", "name": "컴퓨터 통신", "reason": "기본 추천"}]
            
        session_data["recommended_personas"] = fallback_personas
        save_mentor_session(session_id, session_data)
        
        return PersonaRecommendation(
            recommended_personas=fallback_personas,
            reasoning="JSON 파싱 오류로 키워드 기반 추천을 제공합니다."
        )
        
    except Exception as e:
        logger.error(f"페르소나 추천 오류: {e}")
        # 기본 추천
        default_personas = [
            {"id": "computer", "name": "컴퓨터 통신", "reason": "일반적으로 많이 문의되는 분야입니다."}
        ]
        session_data["recommended_personas"] = default_personas
        save_mentor_session(session_id, session_data)
        
        return PersonaRecommendation(
            recommended_personas=default_personas,
            reasoning="분석 중 오류가 발생하여 기본 추천을 제공합니다."
        )

@mcp.tool()
async def select_persona(persona_id: str, session_id: str) -> SelectionResult:
    """사용자가 선택한 페르소나로 멘토링 모드 전환"""
    
    # 디버깅용 로그
    logger.info(f"select_persona 호출 - persona_id: {persona_id}, session_id: {session_id}")
    
    # 세션 파일 경로 확인
    session_file_path = get_mentor_session_file_path(session_id)
    logger.info(f"세션 파일 경로: {session_file_path}")
    logger.info(f"세션 파일 존재 여부: {os.path.exists(session_file_path)}")
    
    # 세션 데이터 로드
    session_data = load_mentor_session(session_id)
    if not session_data:
        logger.error(f"세션 데이터 로드 실패 - session_id: {session_id}")
        
        # 세션 파일이 있는지 다시 한번 체크
        if os.path.exists(session_file_path):
            logger.error("세션 파일은 존재하지만 로드에 실패했습니다.")
            try:
                with open(session_file_path, 'r', encoding='utf-8') as f:
                    raw_content = f.read()
                    logger.info(f"세션 파일 내용: {raw_content[:200]}...")
                    # JSON 파싱 재시도
                    session_data = json.loads(raw_content)
                    logger.info("세션 데이터 재로드 성공!")
            except Exception as parse_error:
                logger.error(f"세션 파일 파싱 오류: {parse_error}")
        
        # 여전히 세션 데이터가 없다면 새 세션 생성
        if not session_data:
            logger.info("새 멘토 세션을 생성합니다.")
            session_data = {
                "session_id": session_id,
                "phase": "persona_recommendation",
                "messages": [],
                "recommended_personas": [],
                "selected_persona": "",
                "persona_context": "",
                "completed": False
            }
            save_mentor_session(session_id, session_data)
            logger.info("새 멘토 세션 저장 완료")
    
    # 페르소나 유효성 검사
    if persona_id not in PERSONAS:
        raise ValueError(f"유효하지 않은 페르소나 ID: {persona_id}")
    
    # 선택된 페르소나 정보
    persona = PERSONAS[persona_id]
    
    # 세션 업데이트
    session_data["selected_persona"] = persona_id
    session_data["phase"] = "mentoring"
    session_data["persona_context"] = persona["system_prompt"]
    
    # 멘토 인사말
    greeting = f"""안녕하세요! 저는 {persona['name']} 분야의 전문가입니다.

전문 분야: {persona['expertise']}

무엇이든 궁금한 것이 있으시면 편하게 물어보세요. 
실무 경험과 전문 지식을 바탕으로 최선을 다해 도움을 드리겠습니다."""
    
    session_data["messages"].append({
        "role": "assistant",
        "content": greeting
    })
    
    save_mentor_session(session_id, session_data)
    
    return SelectionResult(
        selected_persona=persona_id,
        persona_name=persona["name"],
        message=greeting
    )

@mcp.tool()
async def expert_mentoring(message: str, session_id: str) -> MentoringResponse:
    """선택된 페르소나로 전문가 멘토링 제공 (K-MOOC DB 연동)"""
    
    # 세션 데이터 로드
    session_data = load_mentor_session(session_id)
    if not session_data or session_data.get("phase") != "mentoring":
        raise ValueError("멘토링 모드가 활성화되지 않았습니다. 먼저 페르소나를 선택해주세요.")
    
    selected_persona_id = session_data.get("selected_persona")
    if not selected_persona_id or selected_persona_id not in PERSONAS:
        raise ValueError("유효한 페르소나가 선택되지 않았습니다.")
    
    persona = PERSONAS[selected_persona_id]
    
    # 사용자 메시지 추가
    session_data["messages"].append({"role": "user", "content": message})
    
    # K-MOOC 강좌 및 문서 검색 (병렬 실행)
    logger.info(f"멘토링 자료 검색 시작 - 질문: {message[:50]}...")
    
    import asyncio
    kmooc_task = search_kmooc_for_mentoring(message, selected_persona_id)
    docs_task = search_documents_for_mentoring(message, selected_persona_id)
    
    try:
        kmooc_courses, documents = await asyncio.gather(kmooc_task, docs_task, return_exceptions=True)
        
        # 예외 처리
        if isinstance(kmooc_courses, Exception):
            logger.error(f"K-MOOC 검색 오류: {kmooc_courses}")
            kmooc_courses = []
        if isinstance(documents, Exception):
            logger.error(f"문서 검색 오류: {documents}")
            documents = []
            
    except Exception as e:
        logger.error(f"검색 실행 오류: {e}")
        kmooc_courses, documents = [], []
    
    # 검색 결과를 컨텍스트로 구성
    search_context = format_search_results(kmooc_courses, documents)
    
    # 대화 기록 생성 (최근 8개 메시지만 - 검색 결과 추가로 토큰 절약)
    recent_messages = session_data["messages"][-8:]
    conversation_history = ""
    for msg in recent_messages[:-1]:  # 현재 메시지 제외
        role = "사용자" if msg["role"] == "user" else "멘토"
        conversation_history += f"{role}: {msg['content'][:200]}...\n"
    
    # 강화된 멘토링 프롬프트 생성
    mentoring_prompt = f"""
{persona['system_prompt']}

=== 관련 학습 자료 ===
{search_context if search_context else "관련 자료를 찾지 못했습니다."}

=== 대화 기록 ===
{conversation_history}

=== 현재 사용자 질문 ===
{message}

위의 역할과 검색된 학습 자료를 참고하여 전문가로서 답변해주세요:

1. **전문 지식 기반 설명**: 해당 분야의 전문 지식을 바탕으로 정확한 정보 제공
2. **관련 강좌 추천**: 검색된 K-MOOC 강좌가 있다면 구체적으로 추천하고 왜 도움이 될지 설명
3. **추가 학습 자료**: 검색된 문서나 자료가 있다면 어떻게 활용할지 가이드
4. **실무 중심 조언**: 실제 업무나 프로젝트에서 어떻게 적용할지 조언
5. **단계별 학습 경로**: 체계적인 학습 방법과 다음 단계 제안

**답변 가이드라인:**
- 검색된 자료를 자연스럽게 답변에 녹여서 활용하세요
- 친근하고 격려하는 멘토의 톤을 유지하세요

답변은 한국어로 작성해주세요.
답변을 길지 않게 1~2줄로만 대화형식으로 작성해주세요.
"""
    
    try:
        response = await llm.ainvoke(mentoring_prompt)
        mentor_response = response.content
        
        logger.info(f"멘토링 응답 생성 완료 - K-MOOC: {len(kmooc_courses)}개, 문서: {len(documents)}개 활용")
        
        # 응답을 세션에 저장
        session_data["messages"].append({
            "role": "assistant",
            "content": mentor_response
        })
        
        save_mentor_session(session_id, session_data)
        
        return MentoringResponse(
            response=mentor_response,
            persona_name=persona["name"],
            related_courses=kmooc_courses[:2],  # 상위 2개 강좌 정보 포함
            related_documents=documents[:1]     # 상위 1개 문서 정보 포함
        )
        
    except Exception as e:
        logger.error(f"멘토링 응답 생성 오류: {e}")
        error_response = f"죄송합니다. 응답 생성 중 오류가 발생했습니다. 다시 질문해주시면 더 나은 답변을 드리도록 하겠습니다."
        
        session_data["messages"].append({
            "role": "assistant",
            "content": error_response
        })
        save_mentor_session(session_id, session_data)
        
        return MentoringResponse(
            response=error_response,
            persona_name=persona["name"],
            related_courses=[],
            related_documents=[]
        )

@mcp.tool()
async def get_mentor_session_status(session_id: str) -> dict:
    """멘토 세션 상태 조회"""
    session_data = load_mentor_session(session_id)
    if not session_data:
        return {"status": "not_found", "message": "세션을 찾을 수 없습니다."}
    
    status_info = {
        "status": "active",
        "phase": session_data.get("phase", "persona_recommendation"),
        "selected_persona": session_data.get("selected_persona", ""),
        "message_count": len(session_data.get("messages", [])),
        "recommended_personas": session_data.get("recommended_personas", [])
    }
    
    if status_info["selected_persona"]:
        persona = PERSONAS.get(status_info["selected_persona"], {})
        status_info["persona_name"] = persona.get("name", "")
        status_info["persona_expertise"] = persona.get("expertise", "")
    
    return status_info

if __name__ == "__main__":
    mcp.run()
